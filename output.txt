Tablas en la base de datos:
- experiences
  Columnas:
  - experience_id
  - experience_relevance
  - experience_created_at
  - experience_updated_at
  - experience_name
  - experience_description
  Claves primarias:
  - experience_id
  Claves foráneas:
- users
  Columnas:
  - user_id
  - user_email_verified_at
  - user_created_at
  - user_updated_at
  - user_password
  - user_name
  - user_email
  - user_remember_token
  Claves primarias:
  - user_id
  Claves foráneas:
- images
  Columnas:
  - image_isResponsive
  - image_created_at
  - image_updated_at
  - image_id
  - image_alt
  - image_name
  - image_url
  Claves primarias:
  - image_id
  Claves foráneas:
- insight_profile
  Columnas:
  - insight_profile_id
  - insight_profile_created_at
  - insight_profile_updated_at
  - insight_id
  - profile_id
  Claves primarias:
  - insight_profile_id
  Claves foráneas:
  - insight_id
  - profile_id
- insight_valueproposition
  Columnas:
  - insight_valueproposition_id
  - insight_id
  - valueproposition_id
  - insight_valueproposition_created_at
  - insight_valueproposition_updated_at
  - insight_valueproposition_description
  Claves primarias:
  - insight_valueproposition_id
  Claves foráneas:
  - insight_id
  - valueproposition_id
- insight_taxonomy
  Columnas:
  - insight_taxonomy_id
  - insight_taxonomy_created_at
  - insight_taxonomy_updated_at
  - taxonomy_id
  - insight_id
  Claves primarias:
  - insight_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - insight_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- insight_source
  Columnas:
  - insight_source_id
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
  - insight_source_quantitativeValue
  - insight_source_created_at
  - insight_source_updated_at
  Claves primarias:
  - insight_source_id
  Claves foráneas:
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
- publications
  Columnas:
  - publication_id
  - image_id
  - user_id
  - publication_created_at
  - publication_updated_at
  - publication_url
  - publication_name
  - publication_description
  Claves primarias:
  - publication_id
  Claves foráneas:
  - image_id
  - user_id
- source_taxonomy
  Columnas:
  - source_taxonomy_id
  - source_taxonomy_created_at
  - source_taxonomy_updated_at
  - source_id
  - taxonomy_id
  Claves primarias:
  - source_taxonomy_id
  Claves foráneas:
  - source_id
  - taxonomy_id
- source_valueproposition
  Columnas:
  - source_valueproposition_id
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
  - source_valueproposition_quantitativeValue
  - source_valueproposition_created_at
  - source_valueproposition_updated_at
  Claves primarias:
  - source_valueproposition_id
  Claves foráneas:
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
- publication_taxonomy
  Columnas:
  - publication_taxonomy_id
  - taxonomy_id
  - publication_id
  - publication_taxonomy_created_at
  - publication_taxonomy_updated_at
  Claves primarias:
  - publication_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - publication_id
- profiles
  Columnas:
  - profile_id
  - profile_created_at
  - profile_updated_at
  - profile_name
  Claves primarias:
  - profile_id
  Claves foráneas:
- source_user
  Columnas:
  - source_user_id
  - source_id
  - user_id
  Claves primarias:
  - source_user_id
  Claves foráneas:
  - source_id
  - user_id
- valuepropositions
  Columnas:
  - valueproposition_id
  - valueproposition_created_at
  - valueproposition_updated_at
  - valueproposition_name
  Claves primarias:
  - valueproposition_id
  Claves foráneas:
- taxonomy_valuepoint
  Columnas:
  - taxonomy_valuepoint_id
  - taxonomy_id
  - valuepoint_id
  - taxonomy_valuepoint_created_at
  - taxonomy_valuepoint_updated_at
  Claves primarias:
  - taxonomy_valuepoint_id
  Claves foráneas:
  - taxonomy_id
  - valuepoint_id
- valuepoints
  Columnas:
  - valuepoint_id
  - valuepoint_created_at
  - valuepoint_updated_at
  - valuepoint_name
  - valuepoint_url
  Claves primarias:
  - valuepoint_id
  Claves foráneas:
Para el siguiente programa se utilizara la definicion de BCNF propuesta por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

Para el algoritmo se utilizar el conjunto de dependencias funcionales no triviales en el que tanto el antecedente como el consecuente son subconjuntos del conjunto de atributos de la descomposición, en lugar de utilizar el conjunto de dependencias no triviales en la proyección del conjunto de dependencias funcionales para esa descomposición esto debido a que para fines del algoritmo para verificar la BCNF los conjuntos funcionan de forma equivalente.

La demostracion formal de dicha afirmacion se encuentra en el README.md del paquete database-auditor.

Para el esquema de relacion
experiences(experience_id, experience_relevance, experience_created_at, experience_updated_at, experience_name, experience_description)
Se tienen las siguientes dependencias funcionales
F={

{experience_id}=>{experience_relevance,experience_created_at,experience_updated_at,experience_name,experience_description}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla experiences cumple con la definicion de BCNF
Para el esquema de relacion
users(user_id, user_email_verified_at, user_created_at, user_updated_at, user_password, user_name, user_email, user_remember_token)
Se tienen las siguientes dependencias funcionales
F={

{user_id}=>{user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla users cumple con la definicion de BCNF
Para el esquema de relacion
images(image_isResponsive, image_created_at, image_updated_at, image_id, image_alt, image_name, image_url)
Se tienen las siguientes dependencias funcionales
F={

{image_id}=>{image_isResponsive,image_created_at,image_updated_at,image_alt,image_name,image_url}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla images cumple con la definicion de BCNF
Para el esquema de relacion
insight_profile(insight_profile_id, insight_profile_created_at, insight_profile_updated_at, insight_id, profile_id)
Se tienen las siguientes dependencias funcionales
F={

{insight_profile_id}=>{insight_profile_created_at,insight_profile_updated_at,insight_id,profile_id}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla insight_profile cumple con la definicion de BCNF
Para el esquema de relacion
insight_valueproposition(insight_valueproposition_id, insight_id, valueproposition_id, insight_valueproposition_created_at, insight_valueproposition_updated_at, insight_valueproposition_description)
Se tienen las siguientes dependencias funcionales
F={

{insight_valueproposition_id}=>{insight_id,valueproposition_id,insight_valueproposition_created_at,insight_valueproposition_updated_at,insight_valueproposition_description}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla insight_valueproposition cumple con la definicion de BCNF
Para el esquema de relacion
insight_taxonomy(insight_taxonomy_id, insight_taxonomy_created_at, insight_taxonomy_updated_at, taxonomy_id, insight_id)
Se tienen las siguientes dependencias funcionales
F={

{insight_taxonomy_id}=>{insight_taxonomy_created_at,insight_taxonomy_updated_at,taxonomy_id,insight_id}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla insight_taxonomy cumple con la definicion de BCNF
Para el esquema de relacion
insights(insight_id, insight_created_at, insight_updated_at, insight_name)
Se tienen las siguientes dependencias funcionales
F={

{insight_id}=>{insight_created_at,insight_updated_at,insight_name}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla insights cumple con la definicion de BCNF
Para el esquema de relacion
insight_source(insight_source_id, insight_id, source_id, taxonomy_qualitativeValue_id, insight_source_quantitativeValue, insight_source_created_at, insight_source_updated_at)
Se tienen las siguientes dependencias funcionales
F={

{insight_source_id}=>{insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla insight_source cumple con la definicion de BCNF
Para el esquema de relacion
sources(source_id, source_created_at, source_updated_at, source_name, source_description)
Se tienen las siguientes dependencias funcionales
F={

{source_id}=>{source_created_at,source_updated_at,source_name,source_description}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla sources cumple con la definicion de BCNF
Para el esquema de relacion
publications(publication_id, image_id, user_id, publication_created_at, publication_updated_at, publication_url, publication_name, publication_description)
Se tienen las siguientes dependencias funcionales
F={

{publication_id}=>{image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla publications cumple con la definicion de BCNF
Para el esquema de relacion
source_taxonomy(source_taxonomy_id, source_taxonomy_created_at, source_taxonomy_updated_at, source_id, taxonomy_id)
Se tienen las siguientes dependencias funcionales
F={

{source_taxonomy_id}=>{source_taxonomy_created_at,source_taxonomy_updated_at,source_id,taxonomy_id}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla source_taxonomy cumple con la definicion de BCNF
Para el esquema de relacion
source_valueproposition(source_valueproposition_id, source_id, valueproposition_id, taxonomy_qualitativeValue_id, source_valueproposition_quantitativeValue, source_valueproposition_created_at, source_valueproposition_updated_at)
Se tienen las siguientes dependencias funcionales
F={

{source_valueproposition_id}=>{source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla source_valueproposition cumple con la definicion de BCNF
Para el esquema de relacion
taxonomies(taxonomy_id, taxonomy_created_at, taxonomy_updated_at, taxonomy_name, taxonomy_url)
Se tienen las siguientes dependencias funcionales
F={

{taxonomy_id}=>{taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla taxonomies cumple con la definicion de BCNF
Para el esquema de relacion
publication_taxonomy(publication_taxonomy_id, taxonomy_id, publication_id, publication_taxonomy_created_at, publication_taxonomy_updated_at)
Se tienen las siguientes dependencias funcionales
F={

{publication_taxonomy_id}=>{taxonomy_id,publication_id,publication_taxonomy_created_at,publication_taxonomy_updated_at}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla publication_taxonomy cumple con la definicion de BCNF
Para el esquema de relacion
profiles(profile_id, profile_created_at, profile_updated_at, profile_name)
Se tienen las siguientes dependencias funcionales
F={

{profile_id}=>{profile_created_at,profile_updated_at,profile_name}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla profiles cumple con la definicion de BCNF
Para el esquema de relacion
source_user(source_user_id, source_id, user_id)
Se tienen las siguientes dependencias funcionales
F={

{source_user_id}=>{source_id,user_id}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla source_user cumple con la definicion de BCNF
Para el esquema de relacion
valuepropositions(valueproposition_id, valueproposition_created_at, valueproposition_updated_at, valueproposition_name)
Se tienen las siguientes dependencias funcionales
F={

{valueproposition_id}=>{valueproposition_created_at,valueproposition_updated_at,valueproposition_name}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla valuepropositions cumple con la definicion de BCNF
Para el esquema de relacion
taxonomy_valuepoint(taxonomy_valuepoint_id, taxonomy_id, valuepoint_id, taxonomy_valuepoint_created_at, taxonomy_valuepoint_updated_at)
Se tienen las siguientes dependencias funcionales
F={

{taxonomy_valuepoint_id}=>{taxonomy_id,valuepoint_id,taxonomy_valuepoint_created_at,taxonomy_valuepoint_updated_at}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla taxonomy_valuepoint cumple con la definicion de BCNF
Para el esquema de relacion
valuepoints(valuepoint_id, valuepoint_created_at, valuepoint_updated_at, valuepoint_name, valuepoint_url)
Se tienen las siguientes dependencias funcionales
F={

{valuepoint_id}=>{valuepoint_created_at,valuepoint_updated_at,valuepoint_name,valuepoint_url}

}
Dado que para toda dependencia funcional no trivial en el conjunto de dependencias funcionales F el antecedente es super clave la tabla valuepoints cumple con la definicion de BCNF
Creando agrupaciones de tablas para aplicarles a cada una el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

Tablas en la base de datos:
- insight_profile
  Columnas:
  - insight_profile_id
  - insight_profile_created_at
  - insight_profile_updated_at
  - insight_id
  - profile_id
  Claves primarias:
  - insight_profile_id
  Claves foráneas:
  - insight_id
  - profile_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- profiles
  Columnas:
  - profile_id
  - profile_created_at
  - profile_updated_at
  - profile_name
  Claves primarias:
  - profile_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={insight_profile_id,insight_profile_created_at,insight_profile_updated_at,insight_id,profile_id,insight_created_at,insight_updated_at,insight_name,profile_created_at,profile_updated_at,profile_name}
D={

insight_profile={insight_profile_id,insight_profile_created_at,insight_profile_updated_at,insight_id,profile_id}

insights={insight_id,insight_created_at,insight_updated_at,insight_name}

profiles={profile_id,profile_created_at,profile_updated_at,profile_name}

}
F={

{insight_profile_id}=>{insight_profile_created_at,insight_profile_updated_at,insight_id,profile_id}

{insight_id}=>{insight_created_at,insight_updated_at,insight_name}

{profile_id}=>{profile_created_at,profile_updated_at,profile_name}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- insight_valueproposition
  Columnas:
  - insight_valueproposition_id
  - insight_id
  - valueproposition_id
  - insight_valueproposition_created_at
  - insight_valueproposition_updated_at
  - insight_valueproposition_description
  Claves primarias:
  - insight_valueproposition_id
  Claves foráneas:
  - insight_id
  - valueproposition_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- valuepropositions
  Columnas:
  - valueproposition_id
  - valueproposition_created_at
  - valueproposition_updated_at
  - valueproposition_name
  Claves primarias:
  - valueproposition_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={insight_valueproposition_id,insight_id,valueproposition_id,insight_valueproposition_created_at,insight_valueproposition_updated_at,insight_valueproposition_description,insight_created_at,insight_updated_at,insight_name,valueproposition_created_at,valueproposition_updated_at,valueproposition_name}
D={

insight_valueproposition={insight_valueproposition_id,insight_id,valueproposition_id,insight_valueproposition_created_at,insight_valueproposition_updated_at,insight_valueproposition_description}

insights={insight_id,insight_created_at,insight_updated_at,insight_name}

valuepropositions={valueproposition_id,valueproposition_created_at,valueproposition_updated_at,valueproposition_name}

}
F={

{insight_valueproposition_id}=>{insight_id,valueproposition_id,insight_valueproposition_created_at,insight_valueproposition_updated_at,insight_valueproposition_description}

{insight_id}=>{insight_created_at,insight_updated_at,insight_name}

{valueproposition_id}=>{valueproposition_created_at,valueproposition_updated_at,valueproposition_name}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- insight_taxonomy
  Columnas:
  - insight_taxonomy_id
  - insight_taxonomy_created_at
  - insight_taxonomy_updated_at
  - taxonomy_id
  - insight_id
  Claves primarias:
  - insight_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - insight_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={insight_taxonomy_id,insight_taxonomy_created_at,insight_taxonomy_updated_at,taxonomy_id,insight_id,insight_created_at,insight_updated_at,insight_name,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}
D={

insight_taxonomy={insight_taxonomy_id,insight_taxonomy_created_at,insight_taxonomy_updated_at,taxonomy_id,insight_id}

insights={insight_id,insight_created_at,insight_updated_at,insight_name}

taxonomies={taxonomy_id,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}
F={

{insight_taxonomy_id}=>{insight_taxonomy_created_at,insight_taxonomy_updated_at,taxonomy_id,insight_id}

{insight_id}=>{insight_created_at,insight_updated_at,insight_name}

{taxonomy_id}=>{taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 | a_4  | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 | a_3  |b_2_4 |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 | a_11 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 | a_4  | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 | a_3  |b_2_4 |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 |b_1_1 |b_1_2 |b_1_3 | a_4  | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 | a_3  |b_2_4 |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 |b_1_1 |b_1_2 |b_1_3 | a_4  | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 | a_3  |b_2_4 |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 | a_11 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |
|b_1_0 |b_1_1 |b_1_2 |b_1_3 | a_4  | a_5  | a_6  | a_7  |b_1_8 |b_1_9 |b_1_10|b_1_11|
|b_2_0 |b_2_1 |b_2_2 | a_3  |b_2_4 |b_2_5 |b_2_6 |b_2_7 | a_8  | a_9  | a_10 | a_11 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- insight_source
  Columnas:
  - insight_source_id
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
  - insight_source_quantitativeValue
  - insight_source_created_at
  - insight_source_updated_at
  Claves primarias:
  - insight_source_id
  Claves foráneas:
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={insight_source_id,insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at,insight_created_at,insight_updated_at,insight_name,source_created_at,source_updated_at,source_name,source_description}
D={

insight_source={insight_source_id,insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}

insights={insight_id,insight_created_at,insight_updated_at,insight_name}

sources={source_id,source_created_at,source_updated_at,source_name,source_description}

}
F={

{insight_source_id}=>{insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}

{insight_id}=>{insight_created_at,insight_updated_at,insight_name}

{source_id}=>{source_created_at,source_updated_at,source_name,source_description}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 | a_10 | a_11 | a_12 | a_13 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 | a_10 | a_11 | a_12 | a_13 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- insight_source
  Columnas:
  - insight_source_id
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
  - insight_source_quantitativeValue
  - insight_source_created_at
  - insight_source_updated_at
  Claves primarias:
  - insight_source_id
  Claves foráneas:
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
- taxonomy_qualitativeValues
  Columnas:
  Claves primarias:
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={insight_source_id,insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}
D={

insight_source={insight_source_id,insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}

taxonomy_qualitativeValues={}

}
F={

{insight_source_id}=>{insight_id,source_id,taxonomy_qualitativeValue_id,insight_source_quantitativeValue,insight_source_created_at,insight_source_updated_at}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0|b_0_1|b_0_2|b_0_3|b_0_4|b_0_5|b_0_6|
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|


| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- publications
  Columnas:
  - publication_id
  - image_id
  - user_id
  - publication_created_at
  - publication_updated_at
  - publication_url
  - publication_name
  - publication_description
  Claves primarias:
  - publication_id
  Claves foráneas:
  - image_id
  - user_id
- images
  Columnas:
  - image_isResponsive
  - image_created_at
  - image_updated_at
  - image_id
  - image_alt
  - image_name
  - image_url
  Claves primarias:
  - image_id
  Claves foráneas:
- users
  Columnas:
  - user_id
  - user_email_verified_at
  - user_created_at
  - user_updated_at
  - user_password
  - user_name
  - user_email
  - user_remember_token
  Claves primarias:
  - user_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={publication_id,image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description,image_isResponsive,image_created_at,image_updated_at,image_alt,image_name,image_url,user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}
D={

publications={publication_id,image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description}

images={image_isResponsive,image_created_at,image_updated_at,image_id,image_alt,image_name,image_url}

users={user_id,user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}

}
F={

{publication_id}=>{image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description}

{image_id}=>{image_isResponsive,image_created_at,image_updated_at,image_alt,image_name,image_url}

{user_id}=>{user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|b_0_16|b_0_17|b_0_18|b_0_19|b_0_20|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13|b_2_14|b_2_15|b_2_16|b_2_17|b_2_18|b_2_19|b_2_20|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|b_0_16|b_0_17|b_0_18|b_0_19|b_0_20|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13| a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|b_0_16|b_0_17|b_0_18|b_0_19|b_0_20|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13| a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13| a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13| a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |b_1_14|b_1_15|b_1_16|b_1_17|b_1_18|b_1_19|b_1_20|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13| a_14 | a_15 | a_16 | a_17 | a_18 | a_19 | a_20 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- source_taxonomy
  Columnas:
  - source_taxonomy_id
  - source_taxonomy_created_at
  - source_taxonomy_updated_at
  - source_id
  - taxonomy_id
  Claves primarias:
  - source_taxonomy_id
  Claves foráneas:
  - source_id
  - taxonomy_id
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={source_taxonomy_id,source_taxonomy_created_at,source_taxonomy_updated_at,source_id,taxonomy_id,source_created_at,source_updated_at,source_name,source_description,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}
D={

source_taxonomy={source_taxonomy_id,source_taxonomy_created_at,source_taxonomy_updated_at,source_id,taxonomy_id}

sources={source_id,source_created_at,source_updated_at,source_name,source_description}

taxonomies={taxonomy_id,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}
F={

{source_taxonomy_id}=>{source_taxonomy_created_at,source_taxonomy_updated_at,source_id,taxonomy_id}

{source_id}=>{source_created_at,source_updated_at,source_name,source_description}

{taxonomy_id}=>{taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 |b_1_1 |b_1_2 | a_3  |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 | a_4  |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- source_valueproposition
  Columnas:
  - source_valueproposition_id
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
  - source_valueproposition_quantitativeValue
  - source_valueproposition_created_at
  - source_valueproposition_updated_at
  Claves primarias:
  - source_valueproposition_id
  Claves foráneas:
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
- valuepropositions
  Columnas:
  - valueproposition_id
  - valueproposition_created_at
  - valueproposition_updated_at
  - valueproposition_name
  Claves primarias:
  - valueproposition_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={source_valueproposition_id,source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at,source_created_at,source_updated_at,source_name,source_description,valueproposition_created_at,valueproposition_updated_at,valueproposition_name}
D={

source_valueproposition={source_valueproposition_id,source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}

sources={source_id,source_created_at,source_updated_at,source_name,source_description}

valuepropositions={valueproposition_id,valueproposition_created_at,valueproposition_updated_at,valueproposition_name}

}
F={

{source_valueproposition_id}=>{source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}

{source_id}=>{source_created_at,source_updated_at,source_name,source_description}

{valueproposition_id}=>{valueproposition_created_at,valueproposition_updated_at,valueproposition_name}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  | a_10 |b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10| a_11 | a_12 | a_13 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  | a_10 |b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10| a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  | a_10 |b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10| a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  | a_10 |b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10| a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 | a_7  | a_8  | a_9  | a_10 |b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10| a_11 | a_12 | a_13 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- source_valueproposition
  Columnas:
  - source_valueproposition_id
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
  - source_valueproposition_quantitativeValue
  - source_valueproposition_created_at
  - source_valueproposition_updated_at
  Claves primarias:
  - source_valueproposition_id
  Claves foráneas:
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
- taxonomy_qualitativeValues
  Columnas:
  Claves primarias:
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={source_valueproposition_id,source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}
D={

source_valueproposition={source_valueproposition_id,source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}

taxonomy_qualitativeValues={}

}
F={

{source_valueproposition_id}=>{source_id,valueproposition_id,taxonomy_qualitativeValue_id,source_valueproposition_quantitativeValue,source_valueproposition_created_at,source_valueproposition_updated_at}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0|b_0_1|b_0_2|b_0_3|b_0_4|b_0_5|b_0_6|
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|


| a_0 | a_1 | a_2 | a_3 | a_4 | a_5 | a_6 |
|b_1_0|b_1_1|b_1_2|b_1_3|b_1_4|b_1_5|b_1_6|

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- publication_taxonomy
  Columnas:
  - publication_taxonomy_id
  - taxonomy_id
  - publication_id
  - publication_taxonomy_created_at
  - publication_taxonomy_updated_at
  Claves primarias:
  - publication_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - publication_id
- publications
  Columnas:
  - publication_id
  - image_id
  - user_id
  - publication_created_at
  - publication_updated_at
  - publication_url
  - publication_name
  - publication_description
  Claves primarias:
  - publication_id
  Claves foráneas:
  - image_id
  - user_id
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={publication_taxonomy_id,taxonomy_id,publication_id,publication_taxonomy_created_at,publication_taxonomy_updated_at,image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}
D={

publication_taxonomy={publication_taxonomy_id,taxonomy_id,publication_id,publication_taxonomy_created_at,publication_taxonomy_updated_at}

publications={publication_id,image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description}

taxonomies={taxonomy_id,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}
F={

{publication_taxonomy_id}=>{taxonomy_id,publication_id,publication_taxonomy_created_at,publication_taxonomy_updated_at}

{publication_id}=>{image_id,user_id,publication_created_at,publication_updated_at,publication_url,publication_name,publication_description}

{taxonomy_id}=>{taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13|b_2_14|b_2_15|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|
|b_1_0 |b_1_1 | a_2  |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 | a_1  |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11| a_12 | a_13 | a_14 | a_15 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|b_0_14|b_0_15|
|b_1_0 |b_1_1 | a_2  |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 | a_1  |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11| a_12 | a_13 | a_14 | a_15 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 |
|b_1_0 |b_1_1 | a_2  |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 | a_1  |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11| a_12 | a_13 | a_14 | a_15 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 |
|b_1_0 |b_1_1 | a_2  |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 | a_1  |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11| a_12 | a_13 | a_14 | a_15 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 | a_14 | a_15 |
|b_1_0 |b_1_1 | a_2  |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 |b_1_12|b_1_13|b_1_14|b_1_15|
|b_2_0 | a_1  |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11| a_12 | a_13 | a_14 | a_15 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- source_user
  Columnas:
  - source_user_id
  - source_id
  - user_id
  Claves primarias:
  - source_user_id
  Claves foráneas:
  - source_id
  - user_id
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
- users
  Columnas:
  - user_id
  - user_email_verified_at
  - user_created_at
  - user_updated_at
  - user_password
  - user_name
  - user_email
  - user_remember_token
  Claves primarias:
  - user_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={source_user_id,source_id,user_id,source_created_at,source_updated_at,source_name,source_description,user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}
D={

source_user={source_user_id,source_id,user_id}

sources={source_id,source_created_at,source_updated_at,source_name,source_description}

users={user_id,user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}

}
F={

{source_user_id}=>{source_id,user_id}

{source_id}=>{source_created_at,source_updated_at,source_name,source_description}

{user_id}=>{user_email_verified_at,user_created_at,user_updated_at,user_password,user_name,user_email,user_remember_token}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|b_2_13|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 | a_3  | a_4  | a_5  | a_6  |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|b_0_13|
|b_1_0 | a_1  |b_1_2 | a_3  | a_4  | a_5  | a_6  |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 | a_3  | a_4  | a_5  | a_6  |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 | a_3  | a_4  | a_5  | a_6  |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |
|b_1_0 | a_1  |b_1_2 | a_3  | a_4  | a_5  | a_6  |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|b_1_13|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 | a_13 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- taxonomy_valuepoint
  Columnas:
  - taxonomy_valuepoint_id
  - taxonomy_id
  - valuepoint_id
  - taxonomy_valuepoint_created_at
  - taxonomy_valuepoint_updated_at
  Claves primarias:
  - taxonomy_valuepoint_id
  Claves foráneas:
  - taxonomy_id
  - valuepoint_id
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
- valuepoints
  Columnas:
  - valuepoint_id
  - valuepoint_created_at
  - valuepoint_updated_at
  - valuepoint_name
  - valuepoint_url
  Claves primarias:
  - valuepoint_id
  Claves foráneas:
Para el siguiente programa se utilizara el Algoritmo 11.1 de Verificación  de la propiedad de concatenación no aditiva propuesto por RAMEZ ELMASRI  y SHAMKANT B. NAVATHE

R={taxonomy_valuepoint_id,taxonomy_id,valuepoint_id,taxonomy_valuepoint_created_at,taxonomy_valuepoint_updated_at,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url,valuepoint_created_at,valuepoint_updated_at,valuepoint_name,valuepoint_url}
D={

taxonomy_valuepoint={taxonomy_valuepoint_id,taxonomy_id,valuepoint_id,taxonomy_valuepoint_created_at,taxonomy_valuepoint_updated_at}

taxonomies={taxonomy_id,taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

valuepoints={valuepoint_id,valuepoint_created_at,valuepoint_updated_at,valuepoint_name,valuepoint_url}

}
F={

{taxonomy_valuepoint_id}=>{taxonomy_id,valuepoint_id,taxonomy_valuepoint_created_at,taxonomy_valuepoint_updated_at}

{taxonomy_id}=>{taxonomy_created_at,taxonomy_updated_at,taxonomy_name,taxonomy_url}

{valuepoint_id}=>{valuepoint_created_at,valuepoint_updated_at,valuepoint_name,valuepoint_url}

}

Cree una matriz inicial S con una fila i por cada relación Ri en D, y una columna j por cada atributo Aj en R.

Asigne S(i, j):= bij en todas las entradas de la matriz. (∗ cada bij es un símbolo distinto asociado a índices (i, j) ∗)

|b_0_0 |b_0_1 |b_0_2 |b_0_3 |b_0_4 |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 |b_1_1 |b_1_2 |b_1_3 |b_1_4 |b_1_5 |b_1_6 |b_1_7 |b_1_8 |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 |b_2_2 |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 |b_2_9 |b_2_10|b_2_11|b_2_12|

Por cada fila i que representa un esquema de relación Ri 
    {por cada columna j que representa un atributo Aj
        {si la (relación Ri incluye un atributo Aj) entonces asignar S(i, j):⫽ aj;};};
            (∗ cada aj es un símbolo distinto asociado a un índice (j) ∗)

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |

Repetir el siguiente bucle hasta que una ejecución completa del mismo no genere cambios en S{por cada dependencia funcional X → Y en F{ para todas las filas de S que tengan los mismos símbolos en las columnas correspondientes a  los atributos de X{ hacer que los símbolos de cada columna que se corresponden con un atributo de  Y sean los mismos en todas esas filas siguiendo este patrón: si cualquiera  de las filas tiene un símbolo a para la columna, hacer que el resto de filas  tengan el mismo símbolo a en la columna. Si no existe un símbolo a para el  atributo en ninguna de las filas, elegir uno de los símbolos b para el atributo  que aparezcan en una de las filas y ajustar el resto de filas a ese valor } } }

| a_0  | a_1  | a_2  | a_3  | a_4  |b_0_5 |b_0_6 |b_0_7 |b_0_8 |b_0_9 |b_0_10|b_0_11|b_0_12|
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |


| a_0  | a_1  | a_2  | a_3  | a_4  | a_5  | a_6  | a_7  | a_8  | a_9  | a_10 | a_11 | a_12 |
|b_1_0 | a_1  |b_1_2 |b_1_3 |b_1_4 | a_5  | a_6  | a_7  | a_8  |b_1_9 |b_1_10|b_1_11|b_1_12|
|b_2_0 |b_2_1 | a_2  |b_2_3 |b_2_4 |b_2_5 |b_2_6 |b_2_7 |b_2_8 | a_9  | a_10 | a_11 | a_12 |

La descomposición D={R1, R2, . . . , Rm} de R Si tiene la propiedad de concatenación sin pérdida (no aditiva) respecto al conjunto de dependencias F en R dado que una fila  está compuesta enteramente por símbolos a
Tablas en la base de datos:
- experiences
  Columnas:
  - experience_id
  - experience_relevance
  - experience_created_at
  - experience_updated_at
  - experience_name
  - experience_description
  Claves primarias:
  - experience_id
  Claves foráneas:
- users
  Columnas:
  - user_id
  - user_email_verified_at
  - user_created_at
  - user_updated_at
  - user_password
  - user_name
  - user_email
  - user_remember_token
  Claves primarias:
  - user_id
  Claves foráneas:
- images
  Columnas:
  - image_isResponsive
  - image_created_at
  - image_updated_at
  - image_id
  - image_alt
  - image_name
  - image_url
  Claves primarias:
  - image_id
  Claves foráneas:
- insight_profile
  Columnas:
  - insight_profile_id
  - insight_profile_created_at
  - insight_profile_updated_at
  - insight_id
  - profile_id
  Claves primarias:
  - insight_profile_id
  Claves foráneas:
  - insight_id
  - profile_id
- insight_valueproposition
  Columnas:
  - insight_valueproposition_id
  - insight_id
  - valueproposition_id
  - insight_valueproposition_created_at
  - insight_valueproposition_updated_at
  - insight_valueproposition_description
  Claves primarias:
  - insight_valueproposition_id
  Claves foráneas:
  - insight_id
  - valueproposition_id
- insight_taxonomy
  Columnas:
  - insight_taxonomy_id
  - insight_taxonomy_created_at
  - insight_taxonomy_updated_at
  - taxonomy_id
  - insight_id
  Claves primarias:
  - insight_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - insight_id
- insights
  Columnas:
  - insight_id
  - insight_created_at
  - insight_updated_at
  - insight_name
  Claves primarias:
  - insight_id
  Claves foráneas:
- insight_source
  Columnas:
  - insight_source_id
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
  - insight_source_quantitativeValue
  - insight_source_created_at
  - insight_source_updated_at
  Claves primarias:
  - insight_source_id
  Claves foráneas:
  - insight_id
  - source_id
  - taxonomy_qualitativeValue_id
- sources
  Columnas:
  - source_id
  - source_created_at
  - source_updated_at
  - source_name
  - source_description
  Claves primarias:
  - source_id
  Claves foráneas:
- publications
  Columnas:
  - publication_id
  - image_id
  - user_id
  - publication_created_at
  - publication_updated_at
  - publication_url
  - publication_name
  - publication_description
  Claves primarias:
  - publication_id
  Claves foráneas:
  - image_id
  - user_id
- source_taxonomy
  Columnas:
  - source_taxonomy_id
  - source_taxonomy_created_at
  - source_taxonomy_updated_at
  - source_id
  - taxonomy_id
  Claves primarias:
  - source_taxonomy_id
  Claves foráneas:
  - source_id
  - taxonomy_id
- source_valueproposition
  Columnas:
  - source_valueproposition_id
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
  - source_valueproposition_quantitativeValue
  - source_valueproposition_created_at
  - source_valueproposition_updated_at
  Claves primarias:
  - source_valueproposition_id
  Claves foráneas:
  - source_id
  - valueproposition_id
  - taxonomy_qualitativeValue_id
- taxonomies
  Columnas:
  - taxonomy_id
  - taxonomy_created_at
  - taxonomy_updated_at
  - taxonomy_name
  - taxonomy_url
  Claves primarias:
  - taxonomy_id
  Claves foráneas:
- publication_taxonomy
  Columnas:
  - publication_taxonomy_id
  - taxonomy_id
  - publication_id
  - publication_taxonomy_created_at
  - publication_taxonomy_updated_at
  Claves primarias:
  - publication_taxonomy_id
  Claves foráneas:
  - taxonomy_id
  - publication_id
- profiles
  Columnas:
  - profile_id
  - profile_created_at
  - profile_updated_at
  - profile_name
  Claves primarias:
  - profile_id
  Claves foráneas:
- source_user
  Columnas:
  - source_user_id
  - source_id
  - user_id
  Claves primarias:
  - source_user_id
  Claves foráneas:
  - source_id
  - user_id
- valuepropositions
  Columnas:
  - valueproposition_id
  - valueproposition_created_at
  - valueproposition_updated_at
  - valueproposition_name
  Claves primarias:
  - valueproposition_id
  Claves foráneas:
- taxonomy_valuepoint
  Columnas:
  - taxonomy_valuepoint_id
  - taxonomy_id
  - valuepoint_id
  - taxonomy_valuepoint_created_at
  - taxonomy_valuepoint_updated_at
  Claves primarias:
  - taxonomy_valuepoint_id
  Claves foráneas:
  - taxonomy_id
  - valuepoint_id
- valuepoints
  Columnas:
  - valuepoint_id
  - valuepoint_created_at
  - valuepoint_updated_at
  - valuepoint_name
  - valuepoint_url
  Claves primarias:
  - valuepoint_id
  Claves foráneas:
